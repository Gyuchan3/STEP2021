# 宿題1

## 予想

ループ順序と最内ループのメモリアクセスの仕方は下表のようになる。最内ループでのメモリアクセスの値が不変である場合は、2つ目のループでのアクセスの仕方も考慮した。

| ループ順序 | c[i][j]     | a[i][k]          | b[k][j]          | 予想 |
| ----- | ---------------- | ---------------- | ---------------- | -----|
| i-j-k | 不変、連続       | 連続             | 連続でない       | 3    |
| i-k-j | 連続             | 不変、連続       | 連続             | 1    |
| j-i-k | 不変、連続でない | 連続             | 連続でない       | 4    |
| j-k-i | 連続でない       | 連続でない       | 不変、連続でない | 6    |
| k-i-j | 連続             | 不変、連続でない | 連続             | 2    |
| k-j-i | 連続でない       | 連続でない       | 不変、連続       | 5    |

メモリアクセスができるだけ不変または連続であるほうが実行速度は速いので、
i-k-j >= k-i-j >> i-j-k >=j-i-k >> k-j-i >= j-k-iの順に実行速度が速いと考えた。

## 結果

```
gcc matrix.c -o matrix
./matrix 1500
```

を実行した時、ループ順序と実行時間の関係は下表のようになった。実行時間は3回測定し平均をとった。 結果はi-k-j > k-i-j > j-i-k > i-j-k > k-j-i >= j-k-iとなった。

| ループ順序 | 実行時間 | 結果| 予想|
| ------ | ----------- | ---- |----|
| i-j-k  | 45.98218967 | 4    |3|
| i-k-j  | 12.97484267 | 1    |1|
| j-i-k  | 20.70521033 | 3    |4|
| j-k-i  | 55.82119667 | 6    |6|
| k-i-j  | 13.245358   | 2    |2|
| k-j-i  | 54.42283867 | 5    |5|

i-j-kがj-i-kよりも2倍以上遅いのが予想外だった。最内ループでのメモリアクセスが連続かどうかには差がないのになぜだろう。

# 宿題2

Pythonではループ順序を入れ替えても速度差がほとんどないのはなぜか。

コンパイラでは実行にかかる時間は機械語の実行による時間のみで、その内の主な時間は行列積の計算の3重forループのメモリアクセスであるからループ順序の影響が大きい。一方インタプリタであるPythonでは実行にかかる時間の主な部分は字句解析、それをもとにした構文解析、構文木の評価であり、メモリアクセスは実行時間への影響が小さいためループ順序を変えても速度差がほとんどなくなるのだと思う。

